---
title: "hw1"
output: html_document
date: "2024-09-10"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction

This is Hao Yan's solution for Homework 1.

## Data

```{r}
library("tidyverse")

## Install the tidytuesdayR package if you don't have it
if (!require("tidytuesdayR", quietly = TRUE)) {
    install.packages("tidytuesdayR")
}

## For the GitHub version of tidytuesdayR (in case the CRAN version is not available)
## you'll need the "remotes" package to install it.
## See for example https://github.com/dslc-io/tidytuesdayR/issues/94 which led
## to tidytuesdayR not been available from CRAN at the end of August 2024

## Install the remotes package if you don't have it
if (!require("remotes", quietly = TRUE)) {
    install.packages("remotes")
}
## Install the tidytuesdayR package (from GitHub) if you don't have it
if (!require("tidytuesdayR", quietly = TRUE)) {
    remotes::install_github("dslc-io/tidytuesdayR")
}

tuesdata <- tidytuesdayR::tt_load("2022-01-18")
chocolate <- tuesdata$chocolate

library("here")

# tests if a directory named "data" exists locally
if (!dir.exists(here("data"))) {
    dir.create(here("data"))
}

# saves data only once (not each time you knit a R Markdown)
if (!file.exists(here("data", "chocolate.RDS"))) {
    url_csv <- "https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2022/2022-01-18/chocolate.csv"
    chocolate <- readr::read_csv(url_csv)

    # save the file to RDS objects
    saveRDS(chocolate, file = here("data", "chocolate.RDS"))
}

chocolate <- readRDS(here("data", "chocolate.RDS"))
as_tibble(chocolate)

glimpse(chocolate)
```

## Part 1: Explore data

1.  Make a histogram of the rating scores to visualize the overall distribution of scores. Change the number of bins from the default to 10, 15, 20, and 25. Pick on the one that you think looks the best. Explain what the difference is when you change the number of bins and explain why you picked the one you did.

```{r}
# 10 bins
ggplot(chocolate, aes(x = rating)) +
  geom_histogram(bins = 10, fill = "brown", color = "black") +
  labs(title = "Histogram with 10 bins", x = "Rating", y = "Frequency")

# 15 bins
ggplot(chocolate, aes(x = rating)) +
  geom_histogram(bins = 15, fill = "brown", color = "black") +
  labs(title = "Histogram with 15 bins", x = "Rating", y = "Frequency")

# 20 bins
ggplot(chocolate, aes(x = rating)) +
  geom_histogram(bins = 20, fill = "brown", color = "black") +
  labs(title = "Histogram with 20 bins", x = "Rating", y = "Frequency")

# 25 bins
ggplot(chocolate, aes(x = rating)) +
  geom_histogram(bins = 25, fill = "brown", color = "black") +
  labs(title = "Histogram with 25 bins", x = "Rating", y = "Frequency")

```

I will also pick the histogram with 15 bins. When the number of bins is small, each bin covers a broader range of data, making the histogram look smoother and more simplified. Increasing the number of bins results in a more detailed histogram, where each bin covers a narrower range of data. In this case, I think the 15 bins plot not only shows the general trend of the data, but also involves enough details.

2.  Consider the countries where the beans originated from. How many reviews come from each country of bean origin?

The tibble generated by following codes will answer the question.

```{r}
# Group by country of bean origin and count the number of reviews
country_review_counts <- chocolate %>%
  group_by(country_of_bean_origin) %>%
  summarise(review_count = n()) %>%
  arrange(desc(review_count))  # Sort by the number of reviews in descending order

# Print the result
print(country_review_counts)
```

3.  What is average rating scores from reviews of chocolate bars that have Ecuador as country_of_bean_origin in this dataset? For this same set of reviews, also calculate (1) the total number of reviews and (2) the standard deviation of the rating scores. Your answer should be a new data frame with these three summary statistics in three columns. Label the name of these columns mean, sd, and total.

```{r}

# Filter the dataset for Ecuador as the country of bean origin and summarize the statistics
ecuador_summary <- chocolate %>%
  filter(country_of_bean_origin == "Ecuador") %>%
  summarise(
    mean = mean(rating, na.rm = TRUE),  # Calculate the mean of the ratings
    sd = sd(rating, na.rm = TRUE),      # Calculate the standard deviation of the ratings
    total = n()                         # Count the total number of reviews
  )

# Print the result
print(ecuador_summary)

```

4.  Which company (name) makes the best chocolate (or has the highest ratings on average) with beans from Ecuador

```{r}
# Filter for Ecuador as the country of bean origin, group by company, and calculate average rating
best_company_ecuador <- chocolate %>%
  filter(country_of_bean_origin == "Ecuador") %>%
  group_by(company_manufacturer) %>%
  summarise(mean_rating = mean(rating, na.rm = TRUE)) %>%
  arrange(desc(mean_rating)) %>%
  slice(1)  # Select the company with the highest average rating

# Print the result
print(best_company_ecuador)

```

5.  Calculate the average rating across all country of origins for beans. Which top 3 countries (for bean origin) have the highest ratings on average?

```{r}
# Group by country of bean origin, calculate the average rating, and sort to get top 3
top_3_countries <- chocolate %>%
  group_by(country_of_bean_origin) %>%
  summarise(mean_rating = mean(rating, na.rm = TRUE)) %>%
  arrange(desc(mean_rating)) %>%
  slice(1:3)  # Select the top 3 countries

# Print the result
print(top_3_countries)
```

6.  Following up on the previous problem, now remove any countries of bean origins that have less than 10 chocolate bar reviews. Now, which top 3 countries have the highest ratings on average?

```{r}
# Group by country of bean origin, count reviews, filter for countries with at least 10 reviews,
# calculate average rating, and sort to get top 3
top_3_countries_filtered <- chocolate %>%
  group_by(country_of_bean_origin) %>%
  summarise(
    mean_rating = mean(rating, na.rm = TRUE),  # Calculate average rating
    review_count = n()  # Count the number of reviews
  ) %>%
  filter(review_count >= 10) %>%  # Remove countries with fewer than 10 reviews
  arrange(desc(mean_rating)) %>%  # Sort by average rating in descending order
  slice(1:3)  # Select the top 3 countries

# Print the result
print(top_3_countries_filtered)

```

7.  

```{r}
# Step 1: Identify countries of bean origin with at least 50 reviews and filter
filtered_chocolate <- chocolate %>%
  group_by(country_of_bean_origin) %>%
  summarise(review_count = n()) %>%
  filter(review_count >= 50) %>%
  inner_join(chocolate, by = "country_of_bean_origin")  # Keep only reviews from these countries

# Step 2: Create a new column for chocolate percentage groups
# First, extract the numeric part of the chocolate percentage column
filtered_chocolate <- filtered_chocolate %>%
  mutate(cocoa_percent_num = as.numeric(substr(cocoa_percent, 1, nchar(cocoa_percent) - 1))) %>%
  mutate(cocoa_percent_group = case_when(
    cocoa_percent_num < 60 ~ "<60%",
    cocoa_percent_num >= 60 & cocoa_percent_num < 70 ~ "60-69%",
    cocoa_percent_num >= 70 & cocoa_percent_num < 90 ~ "70-89%",
    cocoa_percent_num >= 90 ~ ">=90%"
  ))

# Step 3: Re-order factor levels for the new cocoa percentage groups
filtered_chocolate <- filtered_chocolate %>%
  mutate(cocoa_percent_group = fct_relevel(cocoa_percent_group, "<60%", "60-69%", "70-89%", ">=90%"))

# Step 4: Create side-by-side boxplots for each country, faceted by country
ggplot(filtered_chocolate, aes(x = cocoa_percent_group, y = rating)) +
  geom_boxplot() +
  facet_wrap(~ country_of_bean_origin) +
  labs(title = "Ratings of Chocolate by Cocoa Percentage Group for Each Country",
       x = "Cocoa Percentage Group",
       y = "Rating") +
  theme_minimal()

# Step 5: Analyze which category of chocolate percentage is most highly rated on average
average_ratings_by_group <- filtered_chocolate %>%
  group_by(cocoa_percent_group) %>%
  summarise(mean_rating = mean(rating, na.rm = TRUE)) %>%
  arrange(desc(mean_rating))

# Print the average ratings by group
print(average_ratings_by_group)
```

The 60-69% category is most highly rated.

```{r}
# Step 1: Group by country and cocoa percentage group, then calculate average rating
country_group_ratings <- filtered_chocolate %>%
  group_by(country_of_bean_origin, cocoa_percent_group) %>%
  summarise(mean_rating = mean(rating, na.rm = TRUE)) %>%
  arrange(country_of_bean_origin, desc(mean_rating))

# Step 2: Find the highest-rated cocoa percentage group for each country
highest_group_per_country <- country_group_ratings %>%
  group_by(country_of_bean_origin) %>%
  slice(1)  # Get the top (highest rated) group for each country

# Step 3: Check if the highest-rated group is "60-69%" for each country
is_60_69_highest <- highest_group_per_country %>%
  mutate(is_60_69_highest = cocoa_percent_group == "60-69%")

# Print the result to see if "60-69%" is the highest rated group in each country
print(is_60_69_highest)

```

## Part 2: Join two datasets together

```{r}

# Load the necessary libraries
library(dplyr)
library(ggplot2)
library(gapminder)

# Load the gapminder dataset
data(gapminder)

# Extract unique country and continent from gapminder
gapminder_continent <- gapminder %>%
  select(country, continent) %>%
  distinct()

# Join the chocolate dataset with the gapminder_continent dataset
chocolate_with_continent <- chocolate %>%
  left_join(gapminder_continent, by = c("country_of_bean_origin" = "country"))

# Filter countries with at least 10 reviews
filtered_chocolate <- chocolate_with_continent %>%
  group_by(country_of_bean_origin) %>%
  filter(n() >= 10) %>%
  ungroup() %>%
  filter(country_of_bean_origin != "Blend")

# Check for NAs in the continent column
na_countries <- filtered_chocolate %>%
  filter(is.na(continent)) %>%
  select(country_of_bean_origin) %>%
  distinct()

print(na_countries)  # This will display countries that have no continent assigned

filtered_chocolate <- filtered_chocolate %>%
  mutate(continent = case_when(
    country_of_bean_origin == "Fiji" ~ "Oceania",
    country_of_bean_origin == "Papua New Guinea" ~ "Oceania",
    country_of_bean_origin == "Sao Tome" ~ "Africa",
    country_of_bean_origin == "Vanuatu" ~ "Oceania",
    country_of_bean_origin == "Trinidad" ~ "Americas",
    country_of_bean_origin == "Belize" ~ "Americas",
    country_of_bean_origin == "Grenada" ~ "Americas",
    country_of_bean_origin == "Congo" ~ "Africa",
    country_of_bean_origin == "Solomon Islands" ~ "Oceania",
    country_of_bean_origin == "St. Lucia" ~ "Americas",
    country_of_bean_origin == "U.S.A." ~ "Americas",  
    TRUE ~ continent  
  ))

print(filtered_chocolate %>% filter(is.na(continent)))

# Create violin plots with ratings on the y-axis and continents on the x-axis
ggplot(filtered_chocolate, aes(x = continent, y = rating)) +
  geom_violin(fill = "lightblue") +
  labs(title = "Violin Plot of Ratings by Continent",
       x = "Continent",
       y = "Rating") +
  theme_minimal()

```

## Part 3: Convert wide data into long data

```{r}
# Load necessary libraries
library(dplyr)
library(tidyr)
library(stringr)

chocolate <- readRDS(here("data", "chocolate.RDS"))

# Step 1: Create new columns for the ingredients
chocolate_with_ingredients <- chocolate %>%
  mutate(
    beans = ifelse(str_detect(ingredients, "B"), 1, 0),
    sugar = ifelse(str_detect(ingredients, "S"), 1, 0),
    cocoa_butter = ifelse(str_detect(ingredients, "C"), 1, 0),
    vanilla = ifelse(str_detect(ingredients, "V"), 1, 0),
    letchin = ifelse(str_detect(ingredients, "L"), 1, 0),
    salt = ifelse(str_detect(ingredients, "Sa"), 1, 0)
  )

# Step 2: Create new columns for the most memorable characteristics
chocolate_with_features <- chocolate_with_ingredients %>%
  mutate(
    char_cocoa = ifelse(str_detect(most_memorable_characteristics, "cocoa"), 1, 0),
    char_sweet = ifelse(str_detect(most_memorable_characteristics, "sweet"), 1, 0),
    char_nutty = ifelse(str_detect(most_memorable_characteristics, "nutty"), 1, 0),
    char_creamy = ifelse(str_detect(most_memorable_characteristics, "creamy"), 1, 0),
    char_roasty = ifelse(str_detect(most_memorable_characteristics, "roasty"), 1, 0),
    char_earthy = ifelse(str_detect(most_memorable_characteristics, "earthy"), 1, 0)
  )

# Step 3: Calculate the mean value of each new column for each year
yearly_means <- chocolate_with_features %>%
  group_by(review_date) %>%
  summarise(
    beans = mean(beans, na.rm = TRUE),
    sugar = mean(sugar, na.rm = TRUE),
    cocoa_butter = mean(cocoa_butter, na.rm = TRUE),
    vanilla = mean(vanilla, na.rm = TRUE),
    letchin = mean(letchin, na.rm = TRUE),
    salt = mean(salt, na.rm = TRUE),
    char_cocoa = mean(char_cocoa, na.rm = TRUE),
    char_sweet = mean(char_sweet, na.rm = TRUE),
    char_nutty = mean(char_nutty, na.rm = TRUE),
    char_creamy = mean(char_creamy, na.rm = TRUE),
    char_roasty = mean(char_roasty, na.rm = TRUE),
    char_earthy = mean(char_earthy, na.rm = TRUE)
  )

# Step 4: Convert the wide dataset into a long dataset
long_format <- yearly_means %>%
  pivot_longer(
    cols = -review_date,  # All columns except the review_date
    names_to = "feature",
    values_to = "mean_score"
  )

# Print the final dataset
print(long_format)
```

## Part 4 Data visualization

```{r}
# Load ggplot2 for plotting
library(ggplot2)

# Create the scatter plot with facets for each feature
ggplot(long_format, aes(x = review_date, y = mean_score)) +
  geom_point(color = "blue", size = 2) +  # Scatter plot points
  geom_smooth(method = "loess", color = "red", se = FALSE) +  # Smoothed non-linear trend line
  facet_wrap(~ feature, scales = "free_y") +  # Facet for each feature, free y-axis scaling
  labs(
    title = "Trends in Chocolate Features Over Time",
    subtitle = "Decreasing creamy, butter, letchin and vanilla",
    x = "Year",
    y = "Mean Score",
    caption = "Created by Hao"
  ) +
  theme_minimal() +  # Clean theme with minimal distractions
  theme(
    plot.title = element_text(size = 18, face = "bold", hjust = 0.5),
    plot.subtitle = element_text(size = 14, hjust = 0.5),
    plot.caption = element_text(size = 10, hjust = 0),
    strip.background = element_rect(fill = "lightblue"),  # Background color for facet labels
    strip.text = element_text(face = "bold", size = 12),
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 10)
  )
```

## Part 5: Make the worst plot you can!

```{r}
# Load ggplot2 for plotting
library(ggplot2)

# Create a bad plot
ggplot(long_format, aes(x = review_date, y = mean_score, color = feature)) +
  geom_point(size = 7, shape = 16) +  
  geom_smooth(method = "loess", se = FALSE, color = "limegreen", linewidth = 3) +  
  facet_wrap(~ feature, ncol = 3) +  
  labs(
    title = "The Worst Chocolate Plot",
    x = "X-Axis",
    y = "Y-Axis",
    caption = "Created by Hao"
  ) +
  theme(
    plot.background = element_rect(fill = "lightyellow"),  
    plot.title = element_text(size = 25, face = "bold", color = "blue"),  
    plot.subtitle = element_text(size = 16, color = "gray"),  
    axis.text.x = element_text(angle = 45, size = 15, color = "purple"),  
    axis.text.y = element_text(size = 8, color = "red"),  
    strip.background = element_rect(fill = "orange"),  
    strip.text = element_text(color = "white", size = 14)  
  )

```

-   I used large circle-shaped points (size = 7) which makes the plot cluttered and hard to read. To make a awesome plot, using smaller points with adequate spacing makes it easier to spot trends without overcrowding the plot.

-   I applied thick (linewidth = 3), bright lime-green smoothing lines, making the plot hard on the eyes. To make a awesome plot, using thinner, more subtle lines allows trends to be visible without overwhelming the data.

-   The title is unnecessarily large (size = 25) and in a bright blue, making it distract from the plot itself. To make a awesome plot, titles should be clear and appropriately sized, helping guide the user without overwhelming them.

-   The x-axis text is large and angled at 45 degrees, making it difficult to read quickly (angle = 45, size = 15). To make a awesome plot, keeping axis text horizontal or at a slight angle ensures readability and enhances user experience.

-   The y-axis text is small (size = 8) and in a bright red color, making it both hard to read and visually jarring. Neutral, medium-sized axis labels improve readability and ensure focus stays on the data.

-   The facet labels have a bright orange background with large white text, drawing too much attention. To improve it, using a subtle background color and appropriately sized text for facet labels ensures that the labels are informative but not distracting.

-   I used non-informative axis labels, which adds to the confusion. Clear, informative axis labels are essential to help the viewer understand what the axes represent.

## Part 6: Make my plot a better plot!

```{r}
chocolate %>%
    ggplot(aes(
        x = as.factor(review_date),
        y = rating,
        fill = review_date
    )) +
    geom_violin()
```

### Improved plot

```{r}
# Load necessary libraries
library(viridis)

# Improved violin plot
chocolate %>%
  ggplot(aes(
    x = as.factor(review_date),
    y = rating,
    fill = as.factor(review_date)
  )) +
  geom_violin(trim = FALSE, scale = "width") +  # Show full data distribution with width scaled to the data
  geom_boxplot(width = 0.1, fill = "white", outlier.shape = NA) +  # Overlay a boxplot to show more precise summary stats
  labs(
    title = "Chocolate Ratings Over Time",
    subtitle = "Comparing the distribution of ratings for different review years",
    x = "Review Year",
    y = "Rating",
    caption = "Source: Chocolate Dataset"
  ) +
  scale_fill_viridis_d(option = "plasma") +  # Use the viridis color palette for many categories
  theme_minimal() +  # Use a clean theme for better data visibility
  theme(
    plot.title = element_text(size = 20, face = "bold", hjust = 0.5),  # Centered, bold title
    plot.subtitle = element_text(size = 14, hjust = 0.5),  # Clear subtitle for context
    axis.text.x = element_text(size = 12, angle = 45, hjust = 1),  # Slanted x-axis labels for better readability
    axis.text.y = element_text(size = 12),  # Increased y-axis text size for better readability
    legend.position = "none"  # Hide legend since it's redundant (fill already matches review years on x-axis)
  )

```

-   Violin Plot Without Trimming (trim = FALSE): I removed the trimming to display the entire distribution of data, including the tails. This ensures that no data points are hidden, giving a fuller picture of the rating distribution.

-   Scaled by Width (scale = "width"): The width of the violins is scaled according to the number of data points for each year. This helps indicate where the data density is higher.

-   Overlaying a Boxplot: I added a boxplot (geom_boxplot()) to provide more precise summary statistics (median, interquartile range) on top of the violin plot. I removed the outliers from the boxplot to keep the view clean.

-   Meaningful Title and Subtitle: The title and subtitle have been improved to give more context and describe what the viewer is looking at.

-   Viridis palette ("plasma" option). This palette supports a larger number of categories, making the plot visually appealing and easy to interpret when dealing with many review years.

-   The x-axis labels have been rotated at 45 degrees and resized for better readability (element_text(size = 12, angle = 45, hjust = 1)), especially when the labels are long or overlapping.

-   The theme_minimal() is used to reduce unnecessary clutter and distractions in the plot. The legend was removed as it was redundant (since the fill is tied to the review_date on the x-axis).

## R session information

```{r}
options(width = 120)
sessioninfo::session_info()
```
